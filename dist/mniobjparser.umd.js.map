{"version":3,"file":"mniobjparser.umd.js","sources":["../src/MniObjParser.js","../src/main.js"],"sourcesContent":["/**\n* MniObjParser is a parser of mniobj surface files. This version is an atempt of\n* making a free from dependency independant module. It is based on the code witten\n* by Nicolas Kassis and Tarek Sherif for BrainBrowser\n* (https://brainbrowser.cbrain.mcgill.ca).\n*\n* Since mniobj file can be huge, it may be a good idea to call that froma worker.\n*\n* @author: Jonathan Lurie (github.com/jonathanlurie)\n* @author: Nicolas Kassis\n* @author: Tarek Sherif\n*/\n\nclass MniObjParser{\n\n  /**\n  * Constructor of the MniObjParser.\n  */\n  constructor(){\n    this._stack = null;\n    this._stackIndex = null;\n    this._tempResult = null;\n    this._shapeData = null;\n  }\n\n\n  /**\n  * Copy an existing MniObjParser instance.\n  * This is particularly usefull in the context of a worker, if an MniObjParser\n  * is returned, it is using a JSON format to transfer, meaning all the methods\n  * are lost and only remains the data. This is to rebuild a proper MniObjParser.\n  * @param {MniObjParser} MniObjParserInstance - the instance to copy the data from.\n  */\n  copy(MniObjParserInstance){\n    this._stack = MniObjParserInstance._stack;\n    this._stackIndex = MniObjParserInstance._stackIndex\n    this._tempResult = MniObjParserInstance._tempResult\n    this._shapeData = MniObjParserInstance._shapeData;\n  }\n\n\n  /**\n  * Parse the nmiobj string.\n  * @param {String} objString - This string is obviously taken out of a obj file\n  */\n  parse(objString) {\n    try{\n      this._parseRawData( objString );\n      this._arrangeData();\n    }catch(e){\n      console.warn(\"MNI OBJ file is invalid.\");\n      console.warn(e);\n    }\n  }\n\n\n  /**\n  * Parse a obj string\n  * @param {String} objString - content of the obj file\n  */\n  _parseRawData( objString ){\n    this._stack = objString.trim().split(/\\s+/).reverse();\n    this._stackIndex = this._stack.length - 1;\n    this._tempResult = {};\n\n    var objectClass = this._popStack();\n    var start, end, nitems;\n    var indices, endIndices;\n    var lineIndices = null;\n    var lineIndexSize, lineIndexCounter;\n\n    this._tempResult.type = objectClass === \"P\" ? \"polygon\" :\n                  objectClass === \"L\" ? \"line\" :\n                  objectClass;\n\n    if(this._tempResult.type === \"polygon\") {\n      this._parseSurfProp();\n      this._tempResult.numVertices = parseInt(this._popStack(), 10);\n      this._parseVertices();\n      this._parseNormals();\n      this._tempResult.nitems = parseInt(this._popStack(), 10);\n    } else if (this._tempResult.type === \"line\") {\n      this._parseSurfProp();\n      this._tempResult.numVertices = parseInt(this._popStack(), 10);\n      this._parseVertices();\n      this._tempResult.nitems = parseInt(this._popStack(), 10);\n    } else {\n      this._tempResult.error = true;\n      this._tempResult.errorMessage = 'Invalid MNI Object class: must be \"polygon\" or \"line\"';\n      return;\n    }\n\n    this._parseColors();\n    this._parseEndIndices();\n    this._parseIndices();\n\n    if (this._tempResult.type === \"polygon\" ) {\n\n    } else if (this._tempResult.type === \"line\") {\n      indices = this._tempResult.indices;\n      endIndices = this._tempResult.endIndices;\n      nitems = this._tempResult.nitems;\n      lineIndexSize = lineIndexCounter = 0;\n\n      for (var i = 0; i < nitems; i++){\n        if (i === 0){\n          start = 0;\n        } else {\n          start = endIndices[i - 1];\n        }\n\n        end = endIndices[i];\n        lineIndexSize += (end - start - 1) * 2;\n      }\n\n      lineIndices = new Uint32Array(lineIndexSize);\n\n      for (var i = 0; i < nitems; i++){\n        if (i === 0){\n          start = 0;\n        } else {\n          start = endIndices[i - 1];\n        }\n\n        lineIndices[lineIndexCounter++] = indices[start];\n        end = endIndices[i];\n\n        for (var j = start + 1; j < end - 1; j++) {\n          lineIndices[lineIndexCounter++] = indices[j];\n          lineIndices[lineIndexCounter++] = indices[j];\n        }\n\n        lineIndices[lineIndexCounter++] = indices[end - 1];\n      }\n\n      this._tempResult.indices = lineIndices;\n    }\n  }\n\n\n  /**\n  * [PRIVATE]\n  * Rearange the data from _tempResult to _shapeData\n  */\n  _arrangeData() {\n\n      this._shapeData = {\n        type: this._tempResult.type,\n        vertices: this._tempResult.vertices,\n        normals: this._tempResult.normals,\n        colors: this._tempResult.colors,\n        surfaceProperties: this._tempResult.surfaceProperties,\n        error: this._tempResult.error,\n        errorMessage: this._tempResult.errorMessage\n      };\n\n      var transfer = [\n        this._shapeData.vertices.buffer,\n        this._shapeData.colors.buffer\n      ];\n\n      if (this._shapeData.normals) {\n        transfer.push(this._shapeData.normals.buffer);\n      }\n\n      this._shapeData.shapes = this._tempResult.indices;\n      \n      transfer.push(\n        this._tempResult.indices.buffer\n      );\n      \n\n      // unroll colors if necessary\n      if(this._shapeData.colors.length === 4) {\n        this._unrollColors();\n      }\n  }\n\n\n  /**\n  * [PRIVATE]\n  * From a single color, make a typed array (Uint8) of colors.\n  */\n  _unrollColors(){\n    var dataColor0, dataColor1, dataColor2, dataColor3;\n    var count;\n    var nbTriangles = this._shapeData.vertices.length / 3;\n    var arraySize = nbTriangles * 4;\n    var unrolledColors = new Uint8Array(arraySize);\n\n    dataColor0 = this._shapeData.colors[0];\n    dataColor1 = this._shapeData.colors[1];\n    dataColor2 = this._shapeData.colors[2];\n    dataColor3 = this._shapeData.colors[3];\n\n    for(var i=0; i<arraySize; i+=4){\n      unrolledColors[i]     = dataColor0 * 255;\n      unrolledColors[i + 1] = dataColor1 * 255;\n      unrolledColors[i + 2] = dataColor2 * 255;\n      unrolledColors[i + 3] = dataColor3 * 255;\n    }\n\n    this._shapeData.colors = unrolledColors;\n  }\n\n\n  /**\n  * [PRIVATE]\n  * Parse surface properties from the raw data.\n  */\n  _parseSurfProp() {\n    if (this._tempResult.type === \"polygon\") {\n      this._tempResult.surfaceProperties = {\n        ambient: parseFloat(this._popStack()),\n        diffuse: parseFloat(this._popStack()),\n        specularReflectance: parseFloat(this._popStack()),\n        specularScattering: parseFloat(this._popStack()),\n        transparency: parseFloat(this._popStack())\n      };\n\n    }else if (this._tempResult.type === \"line\") {\n      this._tempResult.surfaceProperties = {\n        width: this._popStack()\n      };\n    }\n  }\n\n\n  /**\n  * [PRIVATE]\n  * Parse the vertices from the raw data.\n  */\n  _parseVertices() {\n    var count = this._tempResult.numVertices * 3;\n    var vertices = new Float32Array(count);\n    var that = this;\n\n    for (var i = 0; i < count; i++) {\n      vertices[i] = parseFloat(this._popStack());\n    }\n\n    this._tempResult.vertices = vertices;\n  }\n\n\n  /**\n  * [PRIVATE]\n  * Parse the normal vector from the raw data.\n  */\n  _parseNormals() {\n    var count = this._tempResult.numVertices * 3;\n    var normals = new Float32Array(count);\n\n    for (var i = 0; i < count; i++) {\n      normals[i] = parseFloat(this._popStack());\n    }\n\n    this._tempResult.normals = normals;\n  }\n\n\n  /**\n  * [PRIVATE]\n  * Parse the color from the raw data.\n  */\n  _parseColors() {\n    var colorFlag = parseInt(this._popStack(), 10);\n    var colors;\n    var count;\n\n    if (colorFlag === 0) {\n      colors = new Float32Array(4);\n      for (var i = 0; i < 4; i++){\n        colors[i] = parseFloat(this._popStack());\n      }\n    } else if (colorFlag === 1) {\n      count = this._tempResult.num_polygons * 4;\n      colors = new Float32Array(count);\n      for (var i = 0; i < count; i++){\n        colors[i] = parseFloat(this._popStack());\n      }\n    } else if (colorFlag === 2) {\n      count = this._tempResult.numVertices * 4;\n      colors = new Float32Array(count);\n      for (var i = 0; i < count; i++){\n        colors[i] = parseFloat(this._popStack());\n      }\n    } else {\n      this._tempResult.error = true;\n      this._tempResult.errorMessage = \"Invalid color flag: \" + colorFlag;\n    }\n\n    this._tempResult.colorFlag = colorFlag;\n    this._tempResult.colors = colors;\n  }\n\n\n  /**\n  * [PRIVATE]\n  * Not sure how useful endIndices are, it was used in BrainBrowser so I kept them.\n  * (is that useful?)\n  */\n  _parseEndIndices(){\n    var count = this._tempResult.nitems;\n    var endIndices = new Uint32Array(count);\n\n    for(var i = 0; i < count; i++){\n      endIndices[i] = parseInt(this._popStack(), 10);\n    }\n\n    this._tempResult.endIndices = endIndices;\n  }\n\n\n  /**\n  * [PRIVATE]\n  * Reads the vertices indices to use to make triangles.\n  */\n  _parseIndices() {\n    var count = this._stackIndex + 1;\n    var indices = new Uint32Array(count);\n\n    for (var i = 0; i < count; i++) {\n      indices[i] = parseInt(this._popStack(), 10);\n    }\n\n    this._tempResult.indices = indices;\n  }\n\n\n  /**\n  * [PRIVATE]\n  * pop the raw data (big string file)\n  * @return {String}\n  */\n  _popStack() {\n    return this._stack[this._stackIndex--];\n  }\n\n\n  /**\n  * Get if the file is valid, after an atempt of parsing\n  * @return {Boolean} true if valid, false if invalid\n  */\n  isValid(){\n    return (!this._shapeData.error);\n  }\n  \n  \n  /**\n  * Get the error message if any\n  * @return {String} the error message, or null if any\n  */\n  getErrorMessage(){\n    return this._shapeData.errorMessage\n  }\n\n\n  /**\n  * [DEBUGGING]\n  * @return {Object} the entire shapeData object.\n  */\n  getShapeData () {\n    return this._shapeData;\n  }\n\n\n  /**\n  * Returns the index of vertices to be used to make triangles, as a typed array.\n  * @return {Uint32Array} Since triangles have 3 vertices, the array contains index such as\n  * [i0, i1, i2, i0, i1, i2, ...].\n  */\n  getShapeRawIndices() {\n    if( this._shapeData.error ){\n      console.warn(\"ERROR while parsing: \" + this._shapeData.errorMessage);\n      return null;\n    }\n    \n    return this._shapeData.shapes;\n  }\n\n\n  /**\n  * Returns the vertice position as a typed array.\n  * @return {Float32Array} of points encoded like [x, y, z, x, y, z, ...]\n  */\n  getRawVertices() {\n    if( this._shapeData.error ){\n      console.warn(\"ERROR while parsing: \" + this._shapeData.errorMessage);\n      return null;\n    }\n    \n    return this._shapeData.vertices;\n  }\n\n\n  /**\n  * Returns the normal vectors as a typed array.\n  * @return {Float32Array} of normal vector encoded like [x, y, z, x, y, z, ...]\n  */\n  getRawNormals() {\n    if( this._shapeData.error ){\n      console.warn(\"ERROR while parsing: \" + this._shapeData.errorMessage);\n      return null;\n    }\n    \n    return this._shapeData.normals;\n  }\n\n\n  /**\n  * Get the colors encoded like [r, g, b, a, r, g, b, a, ...]\n  * @return {Float32Array} of size 4 or of size 4xnumOfVertices\n  */\n  getRawColors(){\n    if( this._shapeData.error ){\n      console.warn(\"ERROR while parsing: \" + this._shapeData.errorMessage);\n      return null;\n    }\n    \n    return this._shapeData.colors;\n  }\n\n\n  /**\n  * The surface properties contains transparency info about specularity transparency\n  * and other nice light-related behaviour thingies.\n  * May be used when building a material, but this is not mandatory.\n  * @return {Object}\n  */\n  getSurfaceProperties(){\n    if( this._shapeData.error ){\n      console.warn(\"ERROR while parsing: \" + this._shapeData.errorMessage);\n      return null;\n    }\n    \n    return this._shapeData.surfaceProperties;\n  }\n\n\n} /* END of class MniObjParser */\n\nexport { MniObjParser };\n","// if we wanted to use foo here:\n\n// but we just want to make it accessible:\nexport { MniObjParser } from './MniObjParser.js';\n"],"names":["MniObjParser","_stack","_stackIndex","_tempResult","_shapeData","MniObjParserInstance","objString","_parseRawData","_arrangeData","e","warn","trim","split","reverse","length","objectClass","_popStack","start","end","nitems","indices","endIndices","lineIndices","lineIndexSize","lineIndexCounter","type","_parseSurfProp","numVertices","parseInt","_parseVertices","_parseNormals","error","errorMessage","_parseColors","_parseEndIndices","_parseIndices","i","Uint32Array","j","vertices","normals","colors","surfaceProperties","transfer","buffer","push","shapes","_unrollColors","dataColor0","dataColor1","dataColor2","dataColor3","nbTriangles","arraySize","unrolledColors","Uint8Array","parseFloat","count","Float32Array","colorFlag","num_polygons"],"mappings":"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"}